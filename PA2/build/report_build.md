# CST 2-3 Build Report

付甲申 2022012206



## 1. 题目分析

题目要求从邻接表构建一个多叉树，为减少复杂性，解题过程中采用**多叉树的二叉树表示法**。用`lc`表示多叉树的`firstChildren`，用`rc`表示多叉树的`nextSibling`。二叉树节点的结构体如下：

```C++
struct Node
{
    Node *lc = nullptr;     // 左孩子是firstChild
    Node *rc = nullptr;     // 右孩子是nextSibling
    Node *parent = nullptr; // 此处设置parent是为了方便移除操作
    int size = 1;           // 子树规模
    int height = 0;         // 树高
}；
```

每个节点都维护自己的子树规模及树高，便于执行查找操作。同时，每个节点维护`parent`指针，指向该节点二叉树意义上的父节点，便于移除操作的执行。

题目的难点之一是如何从输入的邻接表构造多叉树。若在输入过程中online构造，考虑到节点编号的无序性，随着二叉树规模的增大，不可避免地会增加搜索的成本。因此，解题过程中先存储邻接表，再遍历邻接表，构建二叉树。邻接表的每一行使用如下结构体表示：

```c++
struct Line
{
    int n;           // 每一行的节点数
    int height = -1; // 这一行的最大子树高
    int size = 0;    // 这一行的总子树规模
    int *data;       // 节点数组
};
```

考虑到每一行代表一个节点的孩子，可以在行结构体内维护`height`和`size`，待所有子节点均构造完成后，将`height`与`size`加1，以更新该行对应的节点。这样可以在一定程度上减少栈的使用。

构造二叉树时，使用**两个栈**。首先将邻接表的第一行对应节点追加到二叉树中，同时进栈（称为`node_stack`），并将邻接表第一行（数字0）压入“调用栈”`call_stack`中，节点数减一。接着，找到栈顶结点对应行，重复上述操作。直至“调用栈”的栈顶元素节点数降至0，此时更新最大子树高度和子树规模。

题目接下来要求对树进行M次子树移动或查询操作，题目中的`cost`实际上为查找一个节点的复杂度。查询操作只需找到对应节点，输出其存储的`size`或`height`即可，复杂度为cost。对于子树移动操作，可以将其分解为一次移除操作、一次插入操作、两次维护树高及规模操作。移除和插入操作的复杂度均为cost。需避免维护操作遍历所有节点。考虑到维护操作仅更改查询路径中的节点，故在查询时可以将路径中的节点存入一个**栈**中，移除/插入操作进行后，只需更新栈中元素的子树规模及高度，复杂度为cost。（事实上，可以将复杂度进一步优化到路径的长度）



## 2. 算法执行步骤

### （1）数据读取及邻接表转二叉树

- 以上述`Line`结构体的形式读取邻接表，存储到`ju`数组中。
- 把根节点及邻接表的第1行中节点入栈`node_stack`，并建立二叉树。把第1行对应索引`0`压入栈`call_stack`中。
- 当`call_stack`不为空时，重复下述操作：
  - 若`call_stack`栈顶索引对应的`Line`中的`n`计数器不为0（即邻接表中这一行的节点的孩子还没有全部进入二叉树），依次进行以下操作：
    - `call_stack`栈顶索引对应`Line`的`n`计数器自减。
    - 把`node_stack`栈顶node对应行的索引压入`call_stack`栈中。
    - 把`node_stack`栈顶node的所有孩子进栈并进树。
  - 若`call_stack`栈顶索引对应的`Line`中的`n`计数器已经为0（即邻接表中这一行的节点的孩子已经全部进入二叉树），依次进行以下操作：
    - `node_stack`栈顶节点(记作`top_node`)的`height`及`size`分别赋值为`call_stack`栈顶Line的`height+1`及`size+1`。
    - `call_stack`的次顶元素（如果存在）的规模`size+=top_node->size`，高度`height=max(height, top_node->height)`。
    - 弹出`node_stack`及`call_stack`的栈顶元素。

### (2) 执行操作

#### ① 子树移动操作

- 子树移除操作

  - 调用`getNode`函数，查找待移动的node并返回，同时将查找路径按顺序压入栈`node_stack`中。

  - 弹出`node_stack`栈顶元素（必为待移动的node）

  - 调用`remove`函数，移除该node。

  - 调用`update_h_and_size`函数，更新`node_stack`（查询路径）中节点的高度和规模。对于规模，直接减掉将要移动的node的规模；对于高度，若将要移动的node碰巧是栈顶node的最大数，则需要遍历栈顶node的所有子树，取其最大值，对于栈中其他元素亦然。

- 子树插入操作

  - 调用`getNode`函数，查找待插入node的父节点并返回，同时将查找路径按顺序压入栈`node_stack`中。
  - 调用`insert`函数，插入。
  - 调用`update_h_and_size`函数，更新`node_stack`中节点的高度及规模。对于规模，直接加上将要插入的node的规模；对于高度，取当前高度与将要插入的node的高度加1中的最大值。

#### ② 查询操作

调用`getNode`函数，不压栈，直接输出返回node的高度或规模即可。

### （3）释放内存



## 3. 复杂度分析

### （1）时间复杂度

#### ① 建二叉树

建造二叉树的时候需要把所有节点均压入栈中，对于每一个节点进进行常数次操作，复杂度为$O(N)$

#### ② 子树移动操作

子树移动操作中，需调用两次`getNode`函数（查找），时间复杂度均为$O(cost)$。调用`remove`及`insert`函数，时间复杂度为$O(1)$。调用`update_h_and_size`函数维护调用路径的高度及规模，对于插入操作，时间复杂度为$O(cost)$；对于移除操作，一般情况下为$O(cost)$，最坏情况下（即移除的子树正好是所有父节点的最大子树）为$O(N)$，且不易优化。

故一般情况下，总体时间复杂度为$O(cost)$。

#### ③ 查询操作

仅需调用`getNode`函数查找，时间复杂度为$O(cost)$。



总体时间复杂度为$O(N+M*cost)$

### (2)空间复杂度

过程中维护了三个规模为N的数组，空间占用分别为8N、20N、4N字节（结构体`Node`的大小为32字节，结构体`Line`的大小为20字节）。二叉树占用32N字节。data数组拼合到一起为4N字节。故总体空间复杂度为$\Omega(68N)$











