# CST LAB2 HashFun Report



## 1. 不同哈希策略的实现

设输入序列为`s`，长度为n，各元素的ASCII码分别为`s[i]`，不同哈希函数的数学公式如下：

### 1.1. “坏“的哈希函数

$$
hash(s, N) = (\sum_{i=0}^{n-1}(s[i]-32) )\% N 
$$

即**累加**各元素的ASCII码减去偏移32（前33个字符不可能在用户名中出现），用到了所有字符的信息，但映射不均匀。例如小于等于10位的字符串会集中在前9500位，对于比较大的字典，数据集中在前面很小的一片区域。同时，不同长度的字符串极可能出现冲突。

### 1.2. “好”的哈希函数

$$
hash(s,N)=(\sum_{i=0}^{n-1}(s[i]-32)*94^{n - i - 1})\% N
$$

该函数将`s`视为**n位94进制数**，其中94是合法字符数，`s[0]`是最高位。当字典足够大时，哈希函数的返回值严格按照输入字符串的字典序，且冲突概率较低，该映射是均匀的。



## 2. 不同冲突策略的实现

### 2.1. 双向平方试探

在`quadratic_probe`结构体中设置了`last_offset_base`变量(`init()`中置0)，假设上次试探的偏置为$k$，则
$$
last\_offset\_base = sign(k)\sqrt {k}
$$
对于每一次试探，首先将`last_choice`**回到原位**。再根据`last_offset`的正负取其下一个试探值，例如若其为-3，则取为4。再将其值平方并追加（减）到`last_choice`上，最后返回取模后的值。

### 2.2. 公共溢出区策略

公共溢出区默认为散列表的后半段，需要修改`insert`函数和`query`函数，使hashing时传入的表长减半：

```c++
int last_choice = (*my_hashing)(entry.my_string, table_size);
if (typeid(my_collision) == typeid(overflow_probe)) // +
   last_choice = (*my_hashing)(entry.my_string, table_size / 2); // +
```

同时，在`overflow_probe`结构体中设置了`overflow_p`变量(`init()`中置为表长的一半)，每次试探后加一并取模。这样，若缓冲区已满，将继续把表的前半部分作为缓冲区，提高表的利用率。



## 3. 进行测试

### 数据特征及构造方法

| 数据名    | 插入操作次数 | 查询操作次数 | 数据特征                                                   | 构造方法                                                     |
| --------- | ------------ | ------------ | ---------------------------------------------------------- | ------------------------------------------------------------ |
| seqential | 400000       | 500000       | 模拟网站数据库的**真实情况**，尽可能包含其数据库中的所有值 | 顺序插入所给数据库中的前400000项和前500000项。               |
| collision | 10000        | 2000000      | 插入操作和查询操作的数据尽可能**引起冲突**                 | 以相同的概率调用`good_hasing`和`bad_hasing`，从数据库中查找能够与上次生成发生冲突的数据，若有则插入，若无则随机生成一个。经计算，有9253 / 10000次冲突。查询数据从插入数据中随机抽样2000000次。 |
| even      | 120000       | 500000       | 所插入和查找数据的分布**尽量均匀**                         | 插入数据分别为数据库中长度为4~15的字符串的前10000个，共120000个。查询数据从插入数据中随机抽样500000次。 |


## 4. 分析结果

### 4.1

“好”的哈希函数性能远远优于“坏”的哈希函数（后者基本慢10倍以上）。由于**“坏”的哈希函数映射不均匀**，冲突的概率远远大于“好”的哈希函数，每次插入和查询操作的平均次数也多于“好”的哈希函数。

### 4.2

双向平方试探性能总体优于线性试探，这在哈希函数较“坏”时最明显（后者基本慢10倍以上）。这是因为双向平方试探能够迅速跳出数据集中的区域，平均试探次数少。

### 4.3

封闭散列的性能显著优于开放散列。当实际数据排列比较紧密且均匀，但冲突概率较小时，开放散列占优势。原因是数据紧密时封闭散列试探次数较多，但开放散列试探次数正比于冲突次数。

### 4.4

实际的数据集中，数据可能具有较强的局部性，导致均匀哈希函数映射范围较为集中，冲突概率较大。

### 4.5

**扩容**：当插入数据量等于散列容量的一半时，把散列容量加倍，原先的散列元素均匀复制到新的散列里（即`new_dic[2*i]=old_dic[i]`）

**缩容**：申请一个容量为当前散列数据量的新散列，然后把当前散列里非空的数据复制到新散列里。



## 5. 实验感想

实现哈希函数和冲突处理策略所用时间较少，基本原理比较简单。但数据生成器设计时间较长，生成冲突数据时运行数据也较长，原因是需要对数据库进行大量查找操作。

如果可以自己制造数据的话，运行时间会明显缩短，并且数据的特征会更显著。



## 6. 文件说明


测试结果及参数保存在`lab2.csv`文件中。

生成数据时命令行参数保存在`generate.sh`文件中。
